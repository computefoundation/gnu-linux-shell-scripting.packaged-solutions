#!/usr/bin/env bash
# 
# Search the selected text (using a search URL) or open all URLs in the selected
# text in a web browser.
# 
# Usage:
#   xselwebutil [options]
# 
# Options:
#   --browser <CMD>      browser (command) to use (e.g. 'firefox -new-tab');
#                        the default will be used if not specified
#   --search-url <URL>   search URL to use; it must contain a "{search\D}"
#                        placeholder (see url-search-placeholder-parser.pl for
#                        more information); if not set, the default will be
#                        used
# 
# Notes:
#   This utility should be bound to a keybinding.
# 
#   A URL is matched when it begins with "http[s]://", "ftp://" or "file://" or
#   ends with one of the top level domains defined by
#   URL_MATCH_TOP_LEVEL_DOMAINS in CONFIGURATIONS.
# 
# Dependencies:
#   URI::Escape perl module (for url-search-placeholder-parser.pl; install with
#     command "cpan URI::Escape").
# 

readonly HERE="$(dirname "${0}")"

# ======= CONFIGURATIONS ==============

# Default browser.
readonly BROWSER='chromium'

# Default search URL.
readonly SEARCH_URL='http://www.google.com/search?q={search\+}'

# Top level domains used to match URLs.
readonly URL_MATCH_TOP_LEVEL_DOMAINS='.com .org .edu .gov .uk .net'

# ======= ! CONFIGURATIONS ==============

OPTS="$(getopt -a -o h --long browser:,search-url:,help -n 'xselwebutil' -- \
    "${@}")"
if [ "$?" -ne 0 ]; then
  # Output errors as a desktop notification since this script is meant to be
  # used with a keybinding and errors printed to stderr will not be seen.
  msg='xselwebutil: unrecognized option or option does not have an argument'
  notify-send "${msg}"
  exit 1
fi
eval set -- "${OPTS}"
while true; do
  case "${1}" in
    --browser) BROWSER="${2}"; shift;;
    --search-url) SEARCH_URL="${2}"; shift;;
    --) shift; break;;
    * ) break;;
  esac
  shift
done

SEL_TXT="$(xsel)"
SEL_TXT="$(echo "${SEL_TXT}" | sed 's/^[ \t]*//;s/[ \t]*$//')"

if [ -n "${SEL_TXT}" ]; then
  rgxTopLvlDomains="$(echo "${URL_MATCH_TOP_LEVEL_DOMAINS}" | tr -s ' ')"
  rgxTopLvlDomains="${rgxTopLvlDomains//'.'/'\.'}"
  rgx='((http[s]?|ftp|file):\/\/)\S+'            # prefix matches
  rgx+='|'                                       # or
  rgx+="\S+(${rgxTopLvlDomains// /|})(?=\s)"     # suffix matches
  URLS_FOR_DIRECT_OPEN=($(echo "${SEL_TXT}" | perl -ne "while(m/(${rgx})/g) \
      { print \"'\$1' \"; }"))

  if [ "${#URLS_FOR_DIRECT_OPEN[@]}" -ge 1 ]; then
    brwsrArgs="${URLS_FOR_DIRECT_OPEN[@]}"
  else
    brwsrArgs="'$("${HERE}/url-search-placeholder-parser.pl" "${SEARCH_URL}" \
        "${SEL_TXT}")'"
  fi

  nohup ${BROWSER} "${brwsrArgs}" &>/dev/null &
fi


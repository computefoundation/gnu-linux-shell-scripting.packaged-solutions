#!/usr/bin/env bash
# 
# File:
#   openurl
# 
# Description:
#   See https://github.com/linux-shell-base/packaged-utilities/tree/master/openurl
# 
# Dependencies:
#   Perl module URI::Escape (Run "cpan URI::Escape" to install).
# 
#   xterm (The terminal emulator used for opening terminal windows; for quick
#     and easy start up, simply download it. If another terminal emulator is
#     preferred, please adjust the command in the TERMINAL function under
#     CONFIGURATIONS).
# 

readonly HERE="$(dirname "${0}")"

# ======= CONFIGURATIONS ==============

# Directory where URL aliases files are stored.
readonly URL_ALIASES_FILES_DIR="${HERE}"

# URL aliases files
readonly URL_ALIASES_FILES=(
  'aliases'
)

# GUI and terminal web browser commands
# Options:
#   1. All URLs for a browser command are opened in a single run. To open each
#      URL for a browser command independently, prepend two colons ("::") to the
#      browser command. Note: This applies only to GUI browsers.
#   2. To run a command after the browser command has run, append two semicolons
#      (";;") to the browser command followed by the command to run. Note: This
#      applies to both GUI and terminal browsers. Note: The command will run
#      once regardless if option #1 is used.
readonly BROWSER_GUI1='/usr/bin/firefox'
readonly BROWSER_GUI2='/usr/bin/firefox -private-window'
readonly BROWSER_GUI3='/usr/bin/chromium'
readonly BROWSER_GUI4='/usr/bin/chromium --incognito'
readonly BROWSER_GUI5=''
readonly BROWSER_GUI6=''
readonly BROWSER_GUI7=''
readonly BROWSER_GUI8=''
readonly BROWSER_GUI9=''
readonly BROWSER_TERM1='/usr/bin/w3m'
readonly BROWSER_TERM2='/usr/bin/w3m -s +120'
readonly BROWSER_TERM3='/usr/bin/lynx --accept_all_cookies'
readonly BROWSER_TERM4=''
readonly BROWSER_TERM5=''
readonly BROWSER_TERM6=''
readonly BROWSER_TERM7=''

# Whether or not to use all arguments as a search query with the default search
# URL if the first argument does not match any alias; will exit otherwise.
readonly SEARCH_IF_ALIAS_NOT_FOUND=true

# Default search URL
readonly DEFAULT_SEARCH_URL='https://www.google.com/search?q={search\+}'

# Top level domains used to match URLs
readonly URL_MATCH_TOP_LEVEL_DOMAINS='.com .org .edu .gov .uk .net'

# Terminal emulator used for opening terminal windows
TERMINAL() {
  local startX=50; local startY=100; local width=110; local height=44
  local geometry="${width}x${height}+${startX}+${startY}"
  
  nohup xterm -xrm 'XTerm.vt100.allowTitleOps: false' -geometry "${geometry}" \
      -fg '#FFFFFF' -bg '#000000' -fa 'size=12:antialias=true' -title "${1}" \
      -e bash -c "eval ${@:2};"' rs=$? && [ $rs -ne 0 ] && sleep 3' \
      &>/dev/null &
}

# Whether or not to open all URLs for a terminal browser in their own individual
# terminal windows; if not, they will be opened in the same terminal window for
# their browser. (The latter works well with browsers that use switchable
# buffers, such as w3m; if a browser does not support buffers, it may not work
# well.) Note: This configuration will not apply when the dump option is used
# as each URL will always be dumped to its own individual terminal window).
readonly OPEN_TERM_BRWSR_URLS_IN_INDV_WIND=false

# Default options used for less when dumping a webpage
readonly DUMP_LESS_OPTS='-IFRXMc'

# ======= ! CONFIGURATIONS ==============

printHelpMessage() {
  if [ "${1}" = 'full' ]; then
    echo -e "openurl - Utility to make using the web easier.\n"
  fi

  echo -ne "\
Usage:
  openurl [options] <url alias> [search queries]
  openurl [options] <search query for default search url>
  openurl [options] <websites/URLs...>

  First usage (examples):
    openurl wikip history of science
    openurl dir phoenix, az %% seattle, wa

  Second usage:
    If a URL alias is not found, all arguments
    will be used as search queries with the default
    search URL (this can be changed in
    CONFIGURATIONS).

  Third usage:
    If any of the arguments begin with \"http[s]://\",
    \"ftp://\" or \"file://\" or end with any of the top
    level domains defined by URL_MATCH_TOP_LEVEL_DOMAINS
    under CONFIGURATIONS, each will be openeded as a URL
    directly.

Options:
  Configurations:
    -g<1-9>  -<1-9>    open in the GUI browser of the given
                       number
    -t<1-7>            open in the terminal browser of the
                       given number
    -d  -dump[+NUM_PAGES]    dump the output of each URL to
                       a terminal window (using terminal
                       browser 1 by default); optionally,
                       jump forward the given number of
                       pages
  Alter usage:
    -s            do not match the first argument with an
                  alias and instead use all arguments as
                  search queries with the default search URL
    -a            match the first N arguments as aliases and
                  use all arguments after the last matching
                  alias as search queries
  Output:
    -c            copy all URLs to the X11 clipboard and do
                  not run anything
  Other:
    -l  --list    list current browser commands
    -h  --help    show help message

Notes:
  Search queries are delimited with \"%%\".
  
  Using any of the browser type or the dump
  option(s) will override all alias and URL
  configuration options in the URL aliases file.
  
  An unsafe URL character in a search query
  will be encoded. This can be prevented by
  escaping it with two backslashes.
"
}

listBrowserCommands() {
  local msg='openurl: Current browser commands:'
  for i in {1..9}; do
    local brwsrVar="BROWSER_GUI${i}"
    local browser="${!brwsrVar}"
    msg+="\nGUI ${i}: ${browser}"
  done
  for i in {1..7}; do
    brwsrVar="BROWSER_TERM${i}"
    browser="${!brwsrVar}"
    msg+="\nTERM ${i}: ${browser}"
  done
  echo -e "${msg}"
}

# printBrwsrVarNotDefMessage:
#   Print an error message for the browser variable not being defined. Argument
#   1 should be how the variable was defined; it must be either "alias", "url"
#   or empty if it was specified with an argument option.
printBrwsrVarNotDefMessage() {
  if [ $# -ge 3 ]; then
    local brwsrValCaps="$(echo -n "${3}"|tr '[:lower:]' '[:upper:]')"
  fi

  if [ "${1}" = 'alias' ]; then
    echo -e "openurl: Browser \"${3}\" selected for alias\n  \"${2}\""\
        "in one of the URL aliases\n  files, however, variable"\
        "BROWSER_${brwsrValCaps} is\n  not defined." 1>&2
  elif [ "${1}" = 'url' ]; then
    echo -e "openurl: Browser \"${3}\" selected for a URL in\n  one of"\
        "the URL aliases files, however, variable\n  BROWSER_${brwsrValCaps}"\
        "is not defined." 1>&2
  else
    echo -e "openurl: Browser \"${2}\" is not defined." 1>&2
  fi

  read -d '' msg <<-EOF
    Please define it under CONFIGURATIONS or
    use a different browser. The value may be
    a new browser command or simply a
    duplicate of another.
	EOF
  
  while read -r line; do echo "  ${line}" 1>&2; done <<< "${msg}"
}

# ============================================
#   Initialization
# ============================================

# DEFAULT/ALIAS CONFIGURATIONS (Assigned by either argument or alias/URL
# configuration options as argument configuration options override all alias
# configuration options. If their values are changed, they will be applied
# everytime a URL is opened unless changed by argument or alias/URL
# configuration options).

# Initial/default browser
BROWSER="${BROWSER_GUI1}"
# Whether or not to dump the page (it is likely not preferrable to set this to
# true by default)
DUMP=false
# Number of pages to skip forward after dumping a URL's output.
DUMP_PG_FWD=0

# UTILITY VARIABLES

# Current browser type
BROWSER_TYPE='GUI' # 'GUI' or 'TERM'; change accordingly if initial/default
                   # browser is changed.

# ============================================
#   Options and arguments
# ============================================

OPTS="$(getopt -a -o 1,2,3,4,5,6,7,8,9,d::,s,a,c,l,h --long g1,g2,g3,g4,g5,g6 \
    --long g7,g8,g9,t1,t2,t3,t4,t5,t6,t7,list,help -n 'openurl' -- \
    "${@}")"
[ "$?" -ne 0 ] && exit 1
eval set -- "${OPTS}" 

while true; do
  case "${1}" in
    --g?|-1|-2|-3|-4|-5|-6|-7|-8|-9)
        [[ "${1}" = '--g'* ]] && brwsrNum="${1:3}" || brwsrNum="${1:1}"
        brwsrVar="BROWSER_GUI${brwsrNum}"
        BROWSER="${!brwsrVar}"
        BROWSER_TYPE='GUI'
        CONFIG_OPT_SET=true
        ;;
    --t?)
        brwsrNum="${1:3}"
        brwsrVar="BROWSER_TERM${brwsrNum}"
        BROWSER="${!brwsrVar}"
        BROWSER_TYPE='TERM'
        CONFIG_OPT_SET=true
        ;;
    -d|-dump)
        DUMP=true; CONFIG_OPT_SET=true
        if [ -n "${2}" ]; then
          arg="${2}"
          [[ "${arg}" = 'ump'* ]] && arg="${arg#'ump'}"
          if [[ "${arg}" =~ ^\+([0-9]{1,3}(\.[0-9])?)$ ]]; then
            DUMP_PG_FWD="${BASH_REMATCH[1]}"
          elif [ -n "${arg}" ]; then
            echo "openurl: invalid option '${1}${2}'" 1>&2; exit 1;
          fi
        fi
        shift
        ;;
    -s) OPT_OVERRIDE_ALIAS_MATCHING=true;;
    -a) OPT_USE_ALL_ARGS_FOR_ALIASES=true;;
    -c) OPT_COPY_URLS_TO_X11_CLIPBOARD=true;;
    --list|-l) listBrowserCommands; exit;;
    --help|-h) printHelpMessage full; exit;;
    --) shift; break;;
    *) break;;
  esac
  shift
done

if [ "$#" -eq 0 ] && [ "${DUMP}" = 'true' ]; then
  echo 'openurl: cannot use option "dump" without arguments' 1>&2
  exit 1
fi

if [ "${OPT_USE_ALL_ARGS_FOR_ALIASES}" = 'true' ]; then
  if [ "${OPT_OVERRIDE_ALIAS_MATCHING}" = 'true' ]; then
    echo 'openurl: cannot use options -s and -a together' 1>&2
    exit 1
  fi
  if [ $# -eq 0 ]; then
    echo -e 'openurl: one or more aliases required\n  with option -a' 1>&2
    exit 1
  fi
fi

if [ -z "${BROWSER}" ]; then
  printBrwsrVarNotDefMessage '' "${BROWSER_TYPE}${brwsrNum}"
  exit 1
fi

if [ "${DUMP}" = 'true' ] && [ "${BROWSER_TYPE}" = 'GUI' ]; then
  BROWSER="${BROWSER_TERM1}"
  BROWSER_TYPE='TERM'
fi

# ============================================
#   Prerequisites
# ============================================

for urlAliasesFile in "${URL_ALIASES_FILES[@]}"; do
  path="${URL_ALIASES_FILES_DIR}/${urlAliasesFile}"
  if [ ! -f "${path}" ]; then
    echo -e "openurl: URL aliases file not found:\n  '${path}'" 1>&2
    exit 1
  fi
  URL_ALIASES_FILES_STR+="${urlAliasesFile}|"
done

# ============================================
#   Main functions
# ============================================

# processAliasConfigOptions:
#   Assign the global configurations values from the configuration option values
#   of an alias.
processAliasConfigOptions() {
  for aliasOpt in ${ALIAS_OPTS[@]}; do
    case "${aliasOpt}" in
      browser*)
        local brwsrVal="${aliasOpt#*=}"
        local brwsrValCaps="$(echo -n "${brwsrVal}"|tr '[:lower:]' '[:upper:]')"
        local brwsrVar="BROWSER_${brwsrValCaps}"
        BROWSER="${!brwsrVar}"
        BROWSER_TYPE="${brwsrValCaps%[0-9]}"

        [ -z "${BROWSER}" ] && printBrwsrVarNotDefMessage 'alias' "${1}" \
            "${brwsrVal}" && exit 1
        ;;
      dump*)
        DUMP=true
        if [[ "${aliasOpt}" = 'dump+'* ]]; then
          DUMP_PG_FWD="${aliasOpt#*+}"
        fi
        if [ -z "${brwsrVar}" ]; then
          BROWSER="${BROWSER_TERM1}"
          BROWSER_TYPE='TERM'
        fi
        ;;
    esac
  done
}

# createBrowserUrlHashes:
#   Create hashes for URLs using the same browser and URLs that are to dump
#   their output and process their final configuration values.
createBrowserUrlHashes() {
  for url_urlOpts in ${URLS_URLSOPTS[@]}; do
    local url_urlOptsArr=(${url_urlOpts//'<>'/ })
    if [[ "${#url_urlOptsArr[@]}" -eq 1 || "${CONFIG_OPT_SET}" = 'true' ]]; then
      if [ "${DUMP}" != 'true' ]; then
        local key="${BROWSER}%%${BROWSER_TYPE}"
        BROWSER_URL_HASHES["${key}"]+=" ${url_urlOptsArr[0]}"
      else
        # add the dump page forward value so that it can be retrieved later
        [ "${DUMP_PG_FWD}" -ne 0 ] && local addPgFwd="<>${DUMP_PG_FWD}";
        local hashVal=" ${url_urlOptsArr[0]}${addPgFwd}"
        BROWSER_URL_DUMP_HASHES["${BROWSER}"]+="${hashVal}"
      fi
    else
      local brwsrVal=
      local hasDumpOpt=
      local pgFwdVal=
      for urlOpt in ${url_urlOptsArr[@]:1}; do
        case "${urlOpt}" in
          browser*) brwsrVal="${urlOpt#*=}";;
          dump*)
            hasDumpOpt=true
            [[ "${urlOpt}" = 'dump+'* ]] && pgFwdVal="${urlOpt#*+}"
            ;;
        esac
      done

      if [[ "${hasDumpOpt}" = 'true' && -z "${brwsrVal}" ]]; then
        brwsrVal='term1'
      fi

      local brwsrValCaps="$(echo -n "${brwsrVal}"|tr '[:lower:]' '[:upper:]')"
      local brwsrVar="BROWSER_${brwsrValCaps}"
      local brwsr="${!brwsrVar}"
      local brwsrType="${brwsrValCaps%[0-9]}"

      [ -z "${brwsr}" ] && printBrwsrVarNotDefMessage 'url' '' "${brwsrVal}" \
          && exit 1

      if [[ ( "${hasDumpOpt}" = 'true' || "${DUMP}" = 'true' ) && ${brwsrType} \
          != 'GUI' ]]; then
        unset addPgFwd
        if [ "${hasDumpOpt}" = 'true' ]; then
          [ -n "${pgFwdVal}" ] && addPgFwd="<>${pgFwdVal}"
        else
          [[ "${DUMP_PG_FWD}" != 0 ]] && addPgFwd="<>${DUMP_PG_FWD}"
        fi

        BROWSER_URL_DUMP_HASHES["${brwsr}"]+=" ${url_urlOptsArr[0]}${addPgFwd}"
      else
        BROWSER_URL_HASHES["${brwsr}%%${brwsrType}"]+=" ${url_urlOptsArr[0]}"
      fi
    fi
  done
}

# finalizeConfigsAndExeBrowser:
#   Finalize configurations and execute browser for one or more URLs.
finalizeConfigsAndExeBrowser() {
  local browser="${1}"
  local browserType="${2}" # 'GUI' or 'TERM'
  local dump="${3}"
  local dumpPgFwd="${4}"
  local urls="${@: 5}"

  # Quotes must be put around URLs because otherwise they will fail to open
  # correctly if they contain special bash characters such as the AND and OR
  # operators.
  local urlsArr=(${urls})
  local termTtl
  for url in "${urlsArr[@]}"; do
    local urlsNew+=" '${url}'"
    if [ "${browserType}" = 'TERM' ]; then
      ttlStrt="${url: 6}"
      { [ "${#urlsArr[@]}" -ge 3 ] && termTtl+="...${ttlStrt%%\?*}"; } || \
      { [ "${#urlsArr[@]}" -gt 1 ] && termTtl+="...${ttlStrt%%&*}"; } || \
          termTtl="${url}"
    fi
  done
  urls="${urlsNew}"

  if [ "${browserType}" = 'TERM' ]; then
    [ "${#urlsArr[@]}" -gt 1 ] && termTtl+='...'
  fi

  if [[ "${browser}" = *';;'* ]]; then
    local postRunCmd="${browser##*';;'}"
    browser="${browser%';;'*}"
  fi

  if [ "${dump}" = 'true' ]; then
    cmd="${browser} -dump ${urls} | less ${DUMP_LESS_OPTS} +${dumpPgFwd}p"
    TERMINAL "${termTtl}" "${cmd}"
  else
    if [ "${browserType}" = 'GUI' ]; then
      if [[ "${browser}" = '::'* ]]; then
        browser="${browser#*'::'}"

        local urlsArr=(${urls})
        for url in "${urlsArr[@]}"; do
          eval nohup "${browser} ${url}" &>/dev/null &
        done
      else
        eval nohup "${browser} ${urls}" &>/dev/null &
      fi
    else
      TERMINAL "${termTtl}" "${browser} ${urls}"
    fi
  fi

  if [ -n "${postRunCmd}" ]; then
    eval "${postRunCmd}"
  fi
}

# ===================================================
#   Open all URL arguments and exit if any are.
# ===================================================

topLevlDomnsRegx="$(echo "${URL_MATCH_TOP_LEVEL_DOMAINS}" | tr -s ' ')"
topLevlDomnsRegx="${topLevlDomnsRegx//'.'/'\.'}"

regx='('                               # begin prefix group
regx+='www\.|'                         # match "www." as a valid prefix
regx+='(http[s]?|ftp|file):\/\/'       # match schemes
regx+=')'                              # end prefix group
regx+='\S+'      # ensure prefix is followed by one or more non-space characters
regx+='|'                              # or match the following
regx+='\S+'      # ensure suffix is preceded by one or more non-space characters
regx+='('                              # begin suffix group
regx+="${topLevlDomnsRegx// /|}"       # match top level domains
regx+=')'                              # end suffix group
regx+='\S*'                            # include trailing non-space characters

URLS_FOR_DIRECT_OPEN=($(echo "${@}" | perl -ne "
  while (m/(${regx})/g) { print \"'\$1' \"; }
"))

if [ "${#URLS_FOR_DIRECT_OPEN[@]}" -ge 1 ]; then
  if [ "${OPT_COPY_URLS_TO_X11_CLIPBOARD}" = 'true' ]; then
    echo -e 'openurl: option -c not allowed when opening URLs directly' 1>&2
    exit 1
  fi

  finalizeConfigsAndExeBrowser "${BROWSER}" "${BROWSER_TYPE}" "${DUMP}" \
      "${DUMP_PG_FWD}" "${URLS_FOR_DIRECT_OPEN[@]}"
  exit
fi

# ===================================================
#   Get and parse all URLs for one or more alias(es) if the alias(es) exist(s).
# ===================================================

# Argument cases:
#   First argument only used as alias:
#     Use the first argument as an alias and all remaining arguments as one or
#     more search queries for the alias's URLs if the alias was found (note:
#     there will always be at least one URL returned for a found alias). Use all
#     arguments as one or more search queries with the default search URL
#     otherwise and if the respective configuration is set respectively.
# 
#   All arguments used as aliases (switch -a):
#     Use each argument after the first as an alias until no more aliases are
#     found and use all remaining arguments as one or more search queries for
#     the aliases URLs if the first argument is a found alias. Print a message
#     and exit otherwise.

if [ -z "${OPT_OVERRIDE_ALIAS_MATCHING}" ]; then
  if [ "${OPT_USE_ALL_ARGS_FOR_ALIASES}" = 'true' ]; then
    aliasesFileParserArgs="${@}"
  else
    aliasesFileParserArgs="${1}"
  fi

  aliasesFileParserOut="$("${HERE}/aliases-file-parser.pl" \
      "${URL_ALIASES_FILES_DIR}" "${URL_ALIASES_FILES_STR}" \
      ${aliasesFileParserArgs})"
fi

if [ -n "${aliasesFileParserOut}" ]; then
  if [[ "${aliasesFileParserOut}" = 'error:'* ]]; then
    echo "error in URL aliases file ${aliasesFileParserOut#'error:'}" 1>&2
    exit 1
  elif [[ "${aliasesFileParserOut}" = 'error_:'* ]]; then
    echo "error in arguments: ${aliasesFileParserOut#'error_:'}" 1>&2
    exit 1
  fi

  initBrowser="${BROWSER}"
  initDump="${DUMP}"
  initDumpPgFwd="${DUMP_PG_FWD}"

  declare -gA BROWSER_URL_HASHES
  declare -gA BROWSER_URL_DUMP_HASHES

  aliases_aliasOpts_urls_urlsOpts=(${aliasesFileParserOut//'<&>'/ })

  numAliasesMtchd="${#aliases_aliasOpts_urls_urlsOpts[@]}"
  urlSearchPlaceholderParserArgs="${@: $((numAliasesMtchd + 1))}"

  for alias_aliasOpts_urls_urlsOpts_indx in \
      "${!aliases_aliasOpts_urls_urlsOpts[@]}"; do

    alias_aliasOpts_urls_urlsOpts="\
      ${aliases_aliasOpts_urls_urlsOpts[${alias_aliasOpts_urls_urlsOpts_indx}]}"

    # Variable formats quick reference:
    #   aliasOpts_urls_urlsOpts[0] (will not exist if alias has no options):
    #     "[alias_opt1[<>alias_opt2]]"
    #   aliasOpts_urls_urlsOpts[1] (will always contain at least one URL):
    #     "URL1[<>opt1[<>opt2]][<|>URL2[<>opt1[<>opt2]][<|>URL3[<>opt1[
    #     <>opt2]]...]]"
    #   ALIAS_OPTS (array; may be empty):
    #     (["alias_opt1" "alias_opt2"])
    #   URLS_URLSOPTS (array; will always contain at least one element):
    #     ("URL1[<>opt1[<>opt2]]" ["URL2[<>opt1[<>opt2]]" ...])

    aliasOpts_urls_urlsOpts=(${alias_aliasOpts_urls_urlsOpts//'<$>'/ })

    setUpUrlsUrlsOptsArr() {
      local urlSrchPlhParserOut="$("${HERE}/search-placeholder-url-parser.pl" \
          "${aliasOpts_urls_urlsOpts["${1}"]}" \
          ${urlSearchPlaceholderParserArgs})"
      [[ "${urlSrchPlhParserOut}" = 'error:'* ]] && \
          echo -e "error in URL aliases file: ${urlSrchPlhParserOut#'error:'}" \
          1>&2 && exit 1
      URLS_URLSOPTS=(${urlSrchPlhParserOut//'<|>'/ })
    }

    if [ ${#aliasOpts_urls_urlsOpts[@]} -eq 1 ]; then
      setUpUrlsUrlsOptsArr '0' "${@}"
    else
      if [ -z "${CONFIG_OPT_SET}" ]; then
        ALIAS_OPTS=(${aliasOpts_urls_urlsOpts[0]//'<>'/ })
        argNum=$((alias_aliasOpts_urls_urlsOpts_indx + 1))
        processAliasConfigOptions "${!argNum}"
      fi

      setUpUrlsUrlsOptsArr '1' "${@}"
    fi

    if [ "${OPT_COPY_URLS_TO_X11_CLIPBOARD}" = 'true' ]; then
      for url_urlOpts in "${URLS_URLSOPTS[@]}"; do
        url_urlOptsArr=(${url_urlOpts//'<>'/ })
        URLS_FOR_X11_CLIPBOARD+=("${url_urlOptsArr[0]}")
      done
      continue
    fi

    # Create hashes for URLs using the same browser so they can be opened with
    # the browser command once rather than individually.
    createBrowserUrlHashes

    for brwsr_brwsrType in "${!BROWSER_URL_HASHES[@]}"
    do
      brwsr="${brwsr_brwsrType%'%%'*}"
      brwsrType="${brwsr_brwsrType#*'%%'}"
      urls="${BROWSER_URL_HASHES["${brwsr_brwsrType}"]}"

      if [ "${OPEN_TERM_BRWSR_URLS_IN_INDV_WIND}" = 'true' ] && [ \
          "${brwsrType}" = 'TERM' ]; then
        for url in ${urls[@]}; do
          finalizeConfigsAndExeBrowser "${brwsr}" ${brwsrType} false 0 "${url}"
        done
      else
        [ "${alias_aliasOpts_urls_urlsOpts_indx}" -eq \
            "$(("${#aliases_aliasOpts_urls_urlsOpts[@]}" - 1))" ] && 
            finalizeConfigsAndExeBrowser "${brwsr}" ${brwsrType} false 0 \
            "${urls[@]}"
      fi
    done

    for brwsr in "${!BROWSER_URL_DUMP_HASHES[@]}"
    do
      urls_urlsDumpPgFwd="${BROWSER_URL_DUMP_HASHES["${brwsr}"]}"

      for urls_urlDumpPgFwd in ${urls_urlsDumpPgFwd[@]}; do
        urls_urlDumpPgFwd=(${urls_urlDumpPgFwd//'<>'/ })

        [ "${#urls_urlDumpPgFwd[@]}" -gt 1 ] && \
            pgFwd="${urls_urlDumpPgFwd[1]}" || pgFwd='0'

        finalizeConfigsAndExeBrowser "${brwsr}" 'TERM' true "${pgFwd}" \
            "${urls_urlDumpPgFwd[0]}"
      done
    done

    BROWSER="${initBrowser}"
    DUMP="${initDump}"
    DUMP_PG_FWD="${initDumpPgFwd}"
  done #!for each alias options and URLs

else
  if [ "${OPT_USE_ALL_ARGS_FOR_ALIASES}" = 'true' ]; then
    echo 'openurl: no aliases found'
    exit
  fi

  if [ "${SEARCH_IF_ALIAS_NOT_FOUND}" != 'true' ]; then
    echo "openurl: alias \"${1}\" not found"
    exit
  fi

  dfltSrchUrlPrsd="$("${HERE}/search-placeholder-url-parser.pl" \
      "${DEFAULT_SEARCH_URL}" "${@}")"

  if [ "${OPT_COPY_URLS_TO_X11_CLIPBOARD}" = 'true' ]; then
    URLS_FOR_X11_CLIPBOARD=("${dfltSrchUrlPrsd}")
  else
    finalizeConfigsAndExeBrowser "${BROWSER}" "${BROWSER_TYPE}" "${DUMP}" \
        "${DUMP_PG_FWD}" "${dfltSrchUrlPrsd}"
  fi
fi

if [[ -n "${URLS_FOR_X11_CLIPBOARD[@]}" ]]; then
  echo "${URLS_FOR_X11_CLIPBOARD[@]}" | xclip -r -selection c
fi

